{
    "_defaultOther": ["zh_G"],
    "origin": {
        "KzpjsN6": "package websocket",
        "xgx7fZu": "Package websocket implements the WebSocket protocol defined in <a href=\"//tools.ietf.org/html/rfc6455\">RFC 6455</a>.",
        "VR8Zt9H": "Overview",
        "nEv3Uuk": "The Conn type represents a WebSocket connection. A server application calls the Upgrader.Upgrade method from an HTTP request handler to get a *Conn:",
        "3BWnxGs": "Call the connection's WriteMessage and ReadMessage methods to send and receive messages as a slice of bytes. This snippet of code shows how to echo messages using these methods:",
        "kDwe2zq": "In above snippet of code, p is a []byte and messageType is an int with value websocket.BinaryMessage or websocket.TextMessage.",
        "PArYsPN": "An application can also send and receive messages using the io.WriteCloser and io.Reader interfaces. To send a message, call the connection NextWriter method to get an io.WriteCloser, write the message to the writer and close the writer when done. To receive a message, call the connection NextReader method to get an io.Reader and read until io.EOF is returned. This snippet shows how to echo messages using the NextWriter and NextReader methods:",
        "eZcQNdk": "Data Messages",
        "MerdgQ3": "The WebSocket protocol distinguishes between text and binary data messages. Text messages are interpreted as UTF-8 encoded text. The interpretation of binary messages is left to the application.",
        "DvRXwkj": "This package uses the TextMessage and BinaryMessage integer constants to identify the two data message types. The ReadMessage and NextReader methods return the type of the received message. The messageType argument to the WriteMessage and NextWriter methods specifies the type of a sent message.",
        "xpcbRmm": "It is the application's responsibility to ensure that text messages are valid UTF-8 encoded text.",
        "Jgfm8vr": "Control Messages",
        "aQUtcGj": "The WebSocket protocol defines three types of control messages: close, ping and pong. Call the connection WriteControl, WriteMessage or NextWriter methods to send a control message to the peer.",
        "SV7zGHZ": "Connections handle received close messages by calling the handler function set with the SetCloseHandler method and by returning a *CloseError from the NextReader, ReadMessage or the message Read method. The default close handler sends a close message to the peer.",
        "MRK7tkU": "Connections handle received ping messages by calling the handler function set with the SetPingHandler method. The default ping handler sends a pong message to the peer.",
        "BEngCng": "Connections handle received pong messages by calling the handler function set with the SetPongHandler method. The default pong handler does nothing. If an application sends ping messages, then the application should set a pong handler to receive the corresponding pong.",
        "jMDBenZ": "The control message handler functions are called from the NextReader, ReadMessage and message reader Read methods. The default close and ping handlers can block these methods for a short time when the handler writes to the connection.",
        "QERNSC4": "The application must read the connection to process close, ping and pong messages sent from the peer. If the application is not otherwise interested in messages from the peer, then the application should start a goroutine to read and discard messages from the peer. A simple example is:",
        "EJmTxWj": "Concurrency",
        "vzFnKMq": "Connections support one concurrent reader and one concurrent writer.",
        "9eDaYQ6": "Applications are responsible for ensuring that no more than one goroutine calls the write methods (NextWriter, SetWriteDeadline, WriteMessage, WriteJSON, EnableWriteCompression, SetCompressionLevel) concurrently and that no more than one goroutine calls the read methods (NextReader, SetReadDeadline, ReadMessage, ReadJSON, SetPongHandler, SetPingHandler) concurrently.",
        "TVp6D6A": "The Close and WriteControl methods can be called concurrently with all other methods.",
        "UtPJEC5": "Origin Considerations",
        "25GTMwL": "Web browsers allow Javascript applications to open a WebSocket connection to any host. It's up to the server to enforce an origin policy using the Origin request header sent by the browser.",
        "CcVDThJ": "The Upgrader calls the function specified in the CheckOrigin field to check the origin. If the CheckOrigin function returns false, then the Upgrade method fails the WebSocket handshake with HTTP status 403.",
        "NP6uzeg": "If the CheckOrigin field is nil, then the Upgrader uses a safe default: fail the handshake if the Origin request header is present and the Origin host is not equal to the Host request header.",
        "cPc9UzL": "The deprecated package-level Upgrade function does not perform origin checking. The application is responsible for checking the Origin header before calling the Upgrade function.",
        "gqA2QVt": "Buffers",
        "zS5FHAY": "Connections buffer network input and output to reduce the number of system calls when reading or writing messages.",
        "G35shSu": "Write buffers are also used for constructing WebSocket frames. See <a href=\"//tools.ietf.org/html/rfc6455#section-5\">RFC 6455, Section 5</a> for a discussion of message framing. A WebSocket frame header is written to the network each time a write buffer is flushed to the network. Decreasing the size of the write buffer can increase the amount of framing overhead on the connection.",
        "7nr3aCV": "The buffer sizes in bytes are specified by the ReadBufferSize and WriteBufferSize fields in the Dialer and Upgrader. The Dialer uses a default size of 4096 when a buffer size field is set to zero. The Upgrader reuses buffers created by the HTTP server when a buffer size field is set to zero. The HTTP server buffers have a size of 4096 at the time of this writing.",
        "rdDY55r": "The buffer sizes do not limit the size of a message that can be read or written by a connection.",
        "mGz5kfq": "Buffers are held for the lifetime of the connection by default. If the Dialer or Upgrader WriteBufferPool field is set, then a connection holds the write buffer only when writing a message.",
        "6Z98cPA": "Applications should tune the buffer sizes to balance memory use and performance. Increasing the buffer size uses more memory, but can reduce the number of system calls to read or write the network. In the case of writing, increasing the buffer size can reduce the number of frame headers written to the network.",
        "fGsLQsw": "Some guidelines for setting buffer parameters are:",
        "TuzjU2y": "Limit the buffer sizes to the maximum expected message size. Buffers larger than the largest message do not provide any benefit.",
        "LcxywFG": "Depending on the distribution of message sizes, setting the buffer size to to a value less than the maximum expected message size can greatly reduce memory use with a small impact on performance. Here's an example: If 99% of the messages are smaller than 256 bytes and the maximum message size is 512 bytes, then a buffer size of 256 bytes will result in 1.01 more system calls than a buffer size of 512 bytes. The memory savings is 50%.",
        "CLAbJhw": "A write buffer pool is useful when the application has a modest number writes over a large number of connections. when buffers are pooled, a larger buffer size has a reduced impact on total memory use and has the benefit of reducing system calls and frame overhead.",
        "UWzESC9": "Compression EXPERIMENTAL",
        "etZ25TT": "Per message compression extensions (<a href=\"//tools.ietf.org/html/rfc7692\">RFC 7692</a>) are experimentally supported by this package in a limited capacity. Setting the EnableCompression option to true in Dialer or Upgrader will attempt to negotiate per message deflate support.",
        "upQ8yjv": "If compression was successfully negotiated with the connection's peer, any message received in compressed form will be automatically decompressed. All Read methods will return uncompressed bytes.",
        "QyJaCCF": "Per message compression of messages written to a connection can be enabled or disabled by calling the corresponding Conn method:",
        "yYXKnZc": "Currently this package does not support compression with \"context takeover\". This means that messages must be compressed and decompressed in isolation, without retaining sliding window or dictionary state across messages. For more details refer to <a href=\"//tools.ietf.org/html/rfc7692\">RFC 7692</a>.",
        "HqyLEMV": "Use of compression is experimental and may result in decreased performance.",
        "4287VSd": "Index",
        "NtRA8zX": "Constants",
        "YE5SXBV": "Variables",
        "ANSGBZN": "Examples",
        "bVjKVup": "Package Files",
        "hC2PLsD": "Close codes defined in <a href=\"//tools.ietf.org/html/rfc6455#section-11.7\">RFC 6455, section 11.7</a>.",
        "4aebPus": "The message types are defined in <a href=\"//tools.ietf.org/html/rfc6455#section-11.8\">RFC 6455, section 11.8</a>.",
        "Zvh5dC9": "DefaultDialer is a dialer with all fields set to the default values.",
        "fqNVeG6": "ErrBadHandshake is returned when the server response to opening handshake is invalid.",
        "xB3jLYF": "ErrCloseSent is returned when the application writes a message to the connection after sending a close message.",
        "8Ldjx2A": "ErrReadLimit is returned when reading a message that is larger than the read limit set for the connection.",
        "5AXqFD4": "FormatCloseMessage formats closeCode and text as a WebSocket close message. An empty message is returned for code CloseNoStatusReceived.",
        "9rg2LHf": "IsCloseError returns boolean indicating whether the error is a *CloseError with one of the specified codes.",
        "tcaUZAE": "IsUnexpectedCloseError returns boolean indicating whether the error is a *CloseError with a code not in the list of expected codes.",
        "pxetLJF": "The websocket.IsUnexpectedCloseError function is useful for identifying application and protocol errors.",
        "DBwxyH9": "This server application works with a client application running in the browser. The client application does not explicitly close the websocket. The only expected close message from the client has the code websocket.CloseGoingAway. All other other close messages are likely the result of an application or protocol error and are logged to aid debugging.",
        "F67CYqR": "Code:",
        "cbF8pV8": "IsWebSocketUpgrade returns true if the client requested upgrade to the WebSocket protocol.",
        "JS8tbTM": "JoinMessages concatenates received messages to create a single io.Reader. The string term is appended to each message. The returned reader does not support concurrent calls to the Read method.",
        "s9ha2R6": "ReadJSON reads the next JSON-encoded message from the connection and stores it in the value pointed to by v.",
        "KLEa9nR": "Deprecated: Use c.ReadJSON instead.",
        "k2dFD8Q": "Subprotocols returns the subprotocols requested by the client in the Sec-Websocket-Protocol header.",
        "FL2vvYg": "WriteJSON writes the JSON encoding of v as a message.",
        "SEKh6SQ": "Deprecated: Use c.WriteJSON instead.",
        "kmxnvnu": "BufferPool represents a pool of buffers. The *sync.Pool type satisfies this interface. The type of the value stored in a pool is not specified.",
        "nd4BRNQ": "CloseError represents a close message.",
        "8wHeWd3": "The Conn type represents a WebSocket connection.",
        "q6pSXTY": "NewClient creates a new client connection using the given net connection. The URL u specifies the host and request URI. Use requestHeader to specify the origin (Origin), subprotocols (Sec-WebSocket-Protocol) and cookies (Cookie). Use the response.Header to get the selected subprotocol (Sec-WebSocket-Protocol) and cookies (Set-Cookie).",
        "qjsrN66": "If the WebSocket handshake fails, ErrBadHandshake is returned along with a non-nil *http.Response so that callers can handle redirects, authentication, etc.",
        "Gf3nGKe": "Deprecated: Use Dialer instead.",
        "632TvFa": "Upgrade upgrades the HTTP server connection to the WebSocket protocol.",
        "5NGzUaV": "Deprecated: Use websocket.Upgrader instead.",
        "vKysKDj": "Upgrade does not perform origin checking. The application is responsible for checking the Origin header before calling Upgrade. An example implementation of the same origin policy check is:",
        "X7CBHWA": "If the endpoint supports subprotocols, then the application is responsible for negotiating the protocol used on the connection. Use the Subprotocols() function to get the subprotocols requested by the client. Use the Sec-Websocket-Protocol response header to specify the subprotocol selected by the application.",
        "XcueveJ": "The responseHeader is included in the response to the client's upgrade request. Use the responseHeader to specify cookies (Set-Cookie) and the negotiated subprotocol (Sec-Websocket-Protocol).",
        "QBHzEUG": "The connection buffers IO to the underlying network connection. The readBufSize and writeBufSize parameters specify the size of the buffers to use. Messages can be larger than the buffers.",
        "dtd77eF": "If the request is not a valid WebSocket handshake, then Upgrade returns an error of type HandshakeError. Applications should handle this error by replying to the client with an HTTP error response.",
        "Re4Lq3P": "Close closes the underlying network connection without sending or waiting for a close message.",
        "wJxvt6D": "CloseHandler returns the current close handler",
        "WCaV3Mc": "EnableWriteCompression enables and disables write compression of subsequent text and binary messages. This function is a noop if compression was not negotiated with the peer.",
        "zB2dQJV": "LocalAddr returns the local network address.",
        "tzmw3fw": "NextReader returns the next data message received from the peer. The returned messageType is either TextMessage or BinaryMessage.",
        "YaMLZSS": "There can be at most one open reader on a connection. NextReader discards the previous message if the application has not already consumed it.",
        "35HbKLH": "Applications must break out of the application's read loop when this method returns a non-nil error value. Errors returned from this method are permanent. Once this method returns a non-nil error, all subsequent calls to this method return the same error.",
        "snHbbPa": "NextWriter returns a writer for the next message to send. The writer's Close method flushes the complete message to the network.",
        "ZFTE6mp": "There can be at most one open writer on a connection. NextWriter closes the previous writer if the application has not already done so.",
        "sVZCgC7": "All message types (TextMessage, BinaryMessage, CloseMessage, PingMessage and PongMessage) are supported.",
        "WQ3sqh8": "PingHandler returns the current ping handler",
        "YSHcWhW": "PongHandler returns the current pong handler",
        "yHkvQAc": "ReadJSON reads the next JSON-encoded message from the connection and stores it in the value pointed to by v.",
        "b2kybyT": "See the documentation for the encoding/json Unmarshal function for details about the conversion of JSON to a Go value.",
        "332sBpb": "ReadMessage is a helper method for getting a reader using NextReader and reading from that reader to a buffer.",
        "8mmFWPf": "RemoteAddr returns the remote network address.",
        "ctE2gJN": "SetCloseHandler sets the handler for close messages received from the peer. The code argument to h is the received close code or CloseNoStatusReceived if the close message is empty. The default close handler sends a close message back to the peer.",
        "reMJBXv": "The handler function is called from the NextReader, ReadMessage and message reader Read methods. The application must read the connection to process close messages as described in the section on Control Messages above.",
        "rgkbhxN": "The connection read methods return a CloseError when a close message is received. Most applications should handle close messages as part of their normal error handling. Applications should only set a close handler when the application must perform some action before sending a close message back to the peer.",
        "BSeTcj6": "SetCompressionLevel sets the flate compression level for subsequent text and binary messages. This function is a noop if compression was not negotiated with the peer. See the compress/flate package for a description of compression levels.",
        "xM9NMzJ": "SetPingHandler sets the handler for ping messages received from the peer. The appData argument to h is the PING message application data. The default ping handler sends a pong to the peer.",
        "e9SQ3p4": "The handler function is called from the NextReader, ReadMessage and message reader Read methods. The application must read the connection to process ping messages as described in the section on Control Messages above.",
        "JzTFD7y": "SetPongHandler sets the handler for pong messages received from the peer. The appData argument to h is the PONG message application data. The default pong handler does nothing.",
        "JBbMMpZ": "The handler function is called from the NextReader, ReadMessage and message reader Read methods. The application must read the connection to process pong messages as described in the section on Control Messages above.",
        "kdWCRhp": "SetReadDeadline sets the read deadline on the underlying network connection. After a read has timed out, the websocket connection state is corrupt and all future reads will return an error. A zero value for t means reads will not time out.",
        "SYUvE64": "SetReadLimit sets the maximum size in bytes for a message read from the peer. If a message exceeds the limit, the connection sends a close message to the peer and returns ErrReadLimit to the application.",
        "5nRL2TY": "SetWriteDeadline sets the write deadline on the underlying network connection. After a write has timed out, the websocket state is corrupt and all future writes will return an error. A zero value for t means writes will not time out.",
        "hF63xT3": "Subprotocol returns the negotiated protocol for the connection.",
        "mvejVSP": "UnderlyingConn returns the internal net.Conn. This can be used to further modifications to connection specific flags.",
        "ZrfcaQD": "WriteControl writes a control message with the given deadline. The allowed message types are CloseMessage, PingMessage and PongMessage.",
        "LeEbf5Z": "WriteJSON writes the JSON encoding of v as a message.",
        "vh2f26A": "See the documentation for encoding/json Marshal for details about the conversion of Go values to JSON.",
        "Q3nBbej": "WriteMessage is a helper method for getting a writer using NextWriter, writing the message and closing the writer.",
        "XSshtLZ": "WritePreparedMessage writes prepared message into connection.",
        "uefpY5h": "A Dialer contains options for connecting to WebSocket server.",
        "P8TXR8q": "Dial creates a new client connection by calling DialContext with a background context.",
        "B7cmEvf": "DialContext creates a new client connection. Use requestHeader to specify the origin (Origin), subprotocols (Sec-WebSocket-Protocol) and cookies (Cookie). Use the response.Header to get the selected subprotocol (Sec-WebSocket-Protocol) and cookies (Set-Cookie).",
        "2HECSsy": "The context will be used in the request and in the Dialer.",
        "qBm2Ueg": "If the WebSocket handshake fails, ErrBadHandshake is returned along with a non-nil *http.Response so that callers can handle redirects, authentication, etcetera. The response body may not contain the entire response and does not need to be closed by the application.",
        "sqSw8KU": "HandshakeError describes an error with the handshake from the peer.",
        "wa4jDrn": "PreparedMessage caches on the wire representations of a message payload. Use PreparedMessage to efficiently send a message payload to multiple connections. PreparedMessage is especially useful when compression is used because the CPU and memory expensive compression operation can be executed once for a given set of compression options.",
        "m9Hyk5Y": "NewPreparedMessage returns an initialized PreparedMessage. You can then send it to connection using WritePreparedMessage method. Valid wire representation will be calculated lazily only once for a set of current connection options.",
        "jr8FrHh": "Upgrader specifies parameters for upgrading an HTTP connection to a WebSocket connection.",
        "3wkQzn8": "Upgrade upgrades the HTTP server connection to the WebSocket protocol.",
        "gWqxm2Z": "The responseHeader is included in the response to the client's upgrade request. Use the responseHeader to specify cookies (Set-Cookie) and the application negotiated subprotocol (Sec-WebSocket-Protocol).",
        "KhuHxcw": "If the upgrade fails, then Upgrade replies to the client with an HTTP error response.",
        "4bE3u3L": "Directories",
        "GVuX4v2": "Path",
        "dPUcbc5": "Synopsis",
        "V3jrrVV": "Command server is a test server for the Autobahn WebSockets Test Suite."
    },
    "zh_G": {
        "KzpjsN6": "包websocket",
        "xgx7fZu": "包websocket實現了 <a href=\"//tools.ietf.org/html/rfc6455\">RFC 6455</a> 中定義的 WebSocket 協議。",
        "VR8Zt9H": "概觀",
        "nEv3Uuk": "Conn類型表示WebSocket連接。服務器應用程序從HTTP請求處理程序調用Upgrader.Upgrade方法以獲取* Conn：",
        "3BWnxGs": "調用連接的WriteMessage和ReadMessage方法以一片字節發送和接收消息。這段代碼顯示瞭如何使用以下方法回顯消息：",
        "kDwe2zq": "在上面的代碼片段中，p是一個[]字節，messageType是一個值為websocket.BinaryMessage或websocket.TextMessage的int。",
        "PArYsPN": "應用程序還可以使用io.WriteCloser和io.Reader接口發送和接收消息。要發送消息，請調用連接NextWriter方法以獲取io.WriteCloser，將消息寫入writer並在完成後關閉writer。要接收消息，請調用連接NextReader方法以獲取io.Reader並讀取，直到返回io.EOF。此代碼段顯示瞭如何使用NextWriter和NextReader方法回顯消息：",
        "eZcQNdk": "數據消息",
        "MerdgQ3": "WebSocket協議區分文本和二進制數據消息。文本消息被解釋為UTF-8編碼的文本。二進制消息的解釋留給應用程序。",
        "DvRXwkj": "此包使用TextMessage和BinaryMessage整數常量來標識兩種數據消息類型。 ReadMessage和NextReader方法返回接收消息的類型。 WriteMessage和NextWriter方法的messageType參數指定已發送消息的類型。",
        "xpcbRmm": "應用程序有責任確保文本消息是有效的UTF-8編碼文本。",
        "Jgfm8vr": "控制消息",
        "aQUtcGj": "WebSocket協議定義了三種類型的控制消息：close，ping和pong。調用連接WriteControl，WriteMessage或NextWriter方法向對等方發送控制消息。",
        "SV7zGHZ": "Connections通過調用使用SetCloseHandler方法設置的處理函數並從NextReader，ReadMessage或消息Read方法返回* CloseError來處理收到的關閉消息。默認關閉處理程序向對等方發送關閉消息。",
        "MRK7tkU": "Connections通過使用SetPingHandler方法調用處理函數集來處理收到的ping消息。默認的ping處理程序向對等方發送pong消息。",
        "BEngCng": "Connections通過調用使用SetPongHandler方法設置的處理函數來處理收到的pong消息。默認的pong處理程序什麼都不做。如果應用程序發送ping消息，則應用程序應設置pong處理程序以接收相應的pong。",
        "jMDBenZ": "從NextReader，ReadMessage和消息讀取器讀取方法調用控制消息處理函數。當處理程序寫入連接時，默認的關閉和ping處理程序可以在短時間內阻止這些方法。",
        "QERNSC4": "應用程序必須讀取連接以處理從對等方發送的close，ping和pong消息。如果應用程序對來自對等方的消息不感興趣，那麼應用程序應該啟動goroutine來讀取和丟棄來自對等方的消息。一個簡單的例子是：",
        "EJmTxWj": "並發",
        "vzFnKMq": "Connections支持一個並發讀者和一個並發編寫器。",
        "9eDaYQ6": "應用程序負責確保不超過一個goroutine同時調用write方法（NextWriter，SetWriteDeadline，WriteMessage，WriteJSON，EnableWriteCompression，SetCompressionLevel），並且不超過一個goroutine調用read方法（NextReader，SetReadDeadline，ReadMessage，ReadJSON，SetPongHandler） ，SetPingHandler）同時發生。",
        "TVp6D6A": "Close和WriteControl方法可以與所有其他方法同時調用。",
        "UtPJEC5": "起源考慮因素",
        "25GTMwL": "Web瀏覽器允許Javascript應用程序打開與任何主機的WebSocket連接。服務器可以使用瀏覽器發送的Origin請求標頭來強制執行原始策略。",
        "CcVDThJ": "Upgrader調用CheckOrigin字段中指定的函數來檢查原點。如果CheckOrigin函數返回false，則Upgrade方法使HTTP狀態403的WebSocket握手失敗。",
        "NP6uzeg": "如果CheckOrigin字段為nil，則Upgrader使用安全默認值：如果Origin請求標頭存在且Origin主機不等於Host請求標頭，則握手失敗。",
        "cPc9UzL": "不推薦使用的包級別升級功能不執行原始檢查。應用程序負責在調用Upgrade函數之前檢查Origin標頭。",
        "gqA2QVt": "緩衝區",
        "zS5FHAY": "連接緩衝網絡輸入和輸出，以減少讀取或寫入消息時的系統調用次數。",
        "G35shSu": "寫緩衝區也用於構造WebSocket幀。有關消息框架的討論，請參見 <a href=\"//tools.ietf.org/html/rfc6455#section-5\">RFC 6455 - 第 5 節</a>。每次將寫入緩衝區刷新到網絡時，都會將WebSocket幀頭寫入網絡。減小寫緩衝區的大小會增加連接上的成幀開銷量。",
        "7nr3aCV": "緩衝區大小（以字節為單位）由Dialer和Upgrader中的ReadBufferSize和WriteBufferSize字段指定。當緩衝區大小字段設置為零時，Dialer使用默認大小4096。當緩衝區大小字段設置為零時，Upgrader重用HTTP服務器創建的緩衝區。在撰寫本文時，HTTP服務器緩衝區的大小為4096。",
        "rdDY55r": "緩衝區大小不限制可由連接讀取或寫入的消息的大小。",
        "mGz5kfq": "默認情況下，緩衝區在連接的生命週期內保留。如果設置了Dialer或Upgrader WriteBufferPool字段，則只有在寫入消息時，連接才會保留寫入緩衝區。",
        "6Z98cPA": "應用程序應調整緩衝區大小以平衡內存使用和性能。增加緩衝區大小會佔用更多內存，但可以減少讀取或寫入網絡的系統調用次數。在寫入的情況下，增加緩衝區大小可以減少寫入網絡的幀頭的數量。",
        "fGsLQsw": "設置緩衝區參數的一些準則是：",
        "TuzjU2y": "將緩衝區大小限制為最大預期消息大小。大於最大消息的緩衝區不提供任何好處。",
        "LcxywFG": "根據消息大小的分佈，將緩衝區大小設置為小於最大預期消息大小的值可以大大減少內存使用，同時對性能影響很小。下面是一個示例：如果99％的消息小於256個字節且最大消息大小為512個字節，則256個字節的緩衝區大小將導致1.01個系統調用比512個字節的緩衝區大小多。節省的內存為50％。",
        "CLAbJhw": "當應用程序具有適當數量的大量連接寫入時，寫緩衝池很有用。當緩衝池合併時，較大的緩衝區大小對總內存使用的影響較小，並具有減少系統調用和幀開銷的好處。",
        "UWzESC9": "壓縮實驗",
        "etZ25TT": "每個郵件壓縮擴展（<a href=\"//tools.ietf.org/html/rfc7692\">RFC 7692</a>）由此程序包以有限的容量通過實驗支持。在Dialer或Upgrader中將EnableCompression選項設置為true將嘗試協商每個消息deflate支持。",
        "upQ8yjv": "如果與連接的對等方成功協商壓縮，則將自動解壓縮以壓縮形式接收的任何消息。所有Read方法都將返回未壓縮的字節。",
        "QyJaCCF": "通過調用相應的Conn方法，可以啟用或禁用寫入連接的消息的每個消息壓縮：",
        "yYXKnZc": "目前，此程序包不支持使用“上下文接管”進行壓縮。這意味著必須單獨壓縮和解壓縮消息，而不保留消息中的滑動窗口或字典狀態。有關更多詳細信息，請參閱 <a href=\"//tools.ietf.org/html/rfc7692\">RFC 7692</a>。",
        "HqyLEMV": "壓縮的使用是實驗性的，可能導致性能下降。",
        "4287VSd": "指數",
        "NtRA8zX": "常量",
        "YE5SXBV": "變量",
        "ANSGBZN": "例子",
        "bVjKVup": "包文件",
        "hC2PLsD": "關閉代碼在 <a href=\"//tools.ietf.org/html/rfc6455#section-11.7\">RFC 6455 - 第 11.7 節</a> 中定義。",
        "4aebPus": "消息類型在 <a href=\"//tools.ietf.org/html/rfc6455#section-11.8\">RFC 6455 - 第 11.8 節</a> 中定義。",
        "Zvh5dC9": "DefaultDialer是一個撥號器，所有字段都設置為默認值。",
        "fqNVeG6": "當服務器對打開握手的響應無效時，將返回ErrBadHandshake。",
        "xB3jLYF": "當應用程序在發送關閉消息後將消息寫入連接時，將返回ErrCloseSent。",
        "8Ldjx2A": "讀取大於為連接設置的讀取限制的消息時，將返回ErrReadLimit。",
        "5AXqFD4": "FormatCloseMessage將closeCode和text格式化為WebSocket關閉消息。代碼CloseNoStatusReceived返回一條空消息。",
        "9rg2LHf": "IsCloseError返回boolean，指示錯誤是否是帶有指定代碼之一的* CloseError。",
        "tcaUZAE": "IsUnexpectedCloseError返回boolean，指示錯誤是否為* CloseError，代碼不在預期代碼列表中。",
        "pxetLJF": "websocket.IsUnexpectedCloseError函數對於識別應用程序和協議錯誤很有用。",
        "DBwxyH9": "此服務器應用程序適用於在瀏覽器中運行的客戶端應用程序客戶端應用程序未顯式關閉websocket。來自客戶端的唯一預期關閉消息具有代碼websocket.CloseGoingAway。所有其他其他關閉消息可能是應用程序或協議錯誤的結果，並記錄以幫助調試。",
        "F67CYqR": "碼：",
        "cbF8pV8": "如果客戶端請求升級到WebSocket協議，則IsWebSocketUpgrade返回true。",
        "JS8tbTM": "JoinMessages連接收到的消息以創建單個io.Reader。字符串術語附加到每條消息。返回的閱讀器不支持對Read方法的並發調用。",
        "s9ha2R6": "ReadJSON從連接讀取下一個JSON編碼的消息，並將其存儲在v指向的值中。",
        "KLEa9nR": "不推薦使用：改用c.ReadJSON。",
        "k2dFD8Q": "子協議返回客戶端在Sec-Websocket-Protocol標頭中請求的子協議。",
        "FL2vvYg": "WriteJSON將v的JSON編碼寫為消息。",
        "SEKh6SQ": "不推薦使用：改用c.WriteJSON。",
        "kmxnvnu": "BufferPool表示緩衝池。 * sync.Pool類型滿足此接口。未指定存儲在池中的值的類型。",
        "nd4BRNQ": "CloseError表示關閉消息。",
        "8wHeWd3": "Conn類型表示WebSocket連接。",
        "q6pSXTY": "NewClient使用給定的網絡連接創建新的客戶端連接。 URL u指定主機和請求URI。使用requestHeader指定源（Origin），子協議（Sec-WebSocket-Protocol）和cookie（Cookie）。使用response.Header獲取所選的子協議（Sec-WebSocket-Protocol）和cookie（Set-Cookie）。",
        "qjsrN66": "如果WebSocket握手失敗，則返回ErrBadHandshake以及非nil * http.Response，以便調用者可以處理重定向，身份驗證等。",
        "Gf3nGKe": "不推薦使用：改用撥號器。",
        "632TvFa": "升級會將HTTP服務器連接升級到WebSocket協議。",
        "5NGzUaV": "不推薦使用：改為使用websocket.Upgrader。",
        "vKysKDj": "升級不執行原點檢查。應用程序負責在調用Upgrade之前檢查Origin標頭。同一原始策略檢查的示例實現是：",
        "X7CBHWA": "如果端點支持子協議，則應用程序負責協商連接上使用的協議。使用Subprotocols（）函數獲取客戶端請求的子協議。使用Sec-Websocket-Protocol響應標頭指定應用程序選擇的子協議。",
        "XcueveJ": "responseHeader包含在對客戶端升級請求的響應中。使用responseHeader指定cookie（Set-Cookie）和協商的子協議（Sec-Websocket-Protocol）。",
        "QBHzEUG": "連接將IO緩衝到底層網絡連接。 readBufSize和writeBufSize參數指定要使用的緩衝區的大小。消息可以大於緩衝區。",
        "dtd77eF": "如果請求不是有效的WebSocket握手，則Upgrade將返回HandshakeError類型的錯誤。應用程序應通過HTTP錯誤響應回复客戶端來處理此錯誤。",
        "Re4Lq3P": "關閉關閉基礎網絡連接而不發送或等待關閉消息。",
        "wJxvt6D": "CloseHandler返回當前的關閉處理程序",
        "WCaV3Mc": "EnableWriteCompression啟用和禁用後續文本和二進制消息的寫入壓縮。如果未與對等方協商壓縮，則此函數為noop。",
        "zB2dQJV": "LocalAddr返回本地網絡地址。",
        "tzmw3fw": "NextReader返回從對等方接收的下一條數據消息。返回的messageType是TextMessage或BinaryMessage。",
        "YaMLZSS": "連接上最多只能有一個打開的閱讀器。如果應用程序尚未使用它，則NextReader會丟棄先前的消息。",
        "35HbKLH": "當此方法返回非零錯誤值時，應用程序必須突破應用程序的讀取循環。從此方法返回的錯誤是永久性的。一旦此方法返回非零錯誤，則對此方法的所有後續調用都將返回相同的錯誤。",
        "snHbbPa": "NextWriter返回寫入以發送下一條消息。 writer的Close方法將完整的消息刷新到網絡。",
        "ZFTE6mp": "連接上最多只能有一個打開的編寫器。如果應用程序尚未執行此操作，NextWriter將關閉上一個編寫器。",
        "sVZCgC7": "支持所有消息類型（TextMessage，BinaryMessage，CloseMessage，PingMessage和PongMessage）。",
        "WQ3sqh8": "PingHandler返回當前的ping處理程序",
        "YSHcWhW": "PongHandler返回當前的pong處理程序",
        "yHkvQAc": "ReadJSON從連接讀取下一個JSON編碼的消息，並將其存儲在v指向的值中。",
        "b2kybyT": "有關將JSON轉換為Go值的詳細信息，請參閱encoding / json Unmarshal函數的文檔。",
        "332sBpb": "ReadMessage是一種輔助方法，用於使用NextReader獲取讀取器並從該讀取器讀取緩衝區。",
        "8mmFWPf": "RemoteAddr返回遠程網絡地址。",
        "ctE2gJN": "SetCloseHandler設置從對等方接收的關閉消息的處理程序。如果關閉消息為空，則h的代碼參數是接收的密碼或CloseNoStatusReceived。默認關閉處理程序將關閉消息發送回對等方。",
        "reMJBXv": "處理程序函數從NextReader，ReadMessage和消息讀取器讀取方法調用。應用程序必須讀取連接以處理關閉消息，如上面的控制消息部分所述。",
        "rgkbhxN": "接收到關閉消息時，連接讀取方法返回CloseError。大多數應用程序應處理關閉消息作為其正常錯誤處理的一部分。應用程序只應在應用程序必須執行某些操作之前設置關閉處理程序，然後才能將關閉消息發送回對等方。",
        "BSeTcj6": "SetCompressionLevel為後續文本和二進制消息設置flate壓縮級別。如果未與對等方協商壓縮，則此函數為noop。有關壓縮級別的說明，請參閱compress / flate包。",
        "xM9NMzJ": "SetPingHandler設置從對等方接收的ping消息的處理程序。 h的appData參數是PING消息應用程序數據。默認的ping處理程序將pong發送給對等方。",
        "e9SQ3p4": "處理程序函數從NextReader，ReadMessage和消息讀取器讀取方法調用。應用程序必須讀取連接以處理ping消息，如上面的控制消息部分所述。",
        "JzTFD7y": "SetPongHandler設置從對等方接收的pong消息的處理程序。 h的appData參數是PONG消息應用程序數據。默認的pong處理程序什麼都不做。",
        "JBbMMpZ": "處理程序函數從NextReader，ReadMessage和消息讀取器讀取方法調用。應用程序必須讀取處理pong消息的連接，如上面的控制消息部分所述。",
        "kdWCRhp": "SetReadDeadline設置底層網絡連接的讀取截止日期。讀取超時後，websocket連接狀態已損壞，所有將來的讀取都將返回錯誤。 t的零值意味著讀取不會超時。",
        "SYUvE64": "SetReadLimit設置從對等方讀取的消息的最大大小（以字節為單位）。如果消息超出限制，則連接會向對等方發送關閉消息，並將ErrReadLimit返回給應用程序。",
        "5nRL2TY": "SetWriteDeadline設置底層網絡連接的寫入期限。寫入超時後，websocket狀態已損壞，所有將來的寫入都將返回錯誤。 t的零值意味著寫入不會超時。",
        "hF63xT3": "子協議返回協商的連接協議。",
        "mvejVSP": "UnderlyingConn返回內部net.Conn。這可用於進一步修改連接特定標誌。",
        "ZrfcaQD": "WriteControl在給定的截止日期之前寫入控制消息。允許的消息類型是CloseMessage，PingMessage和PongMessage。",
        "LeEbf5Z": "WriteJSON將v的JSON編碼寫為消息。",
        "vh2f26A": "有關將Go值轉換為JSON的詳細信息，請參閱encoding / json Marshal的文檔。",
        "Q3nBbej": "WriteMessage是一個輔助方法，用於使用NextWriter獲取編寫器，編寫消息並關閉編寫器。",
        "XSshtLZ": "WritePreparedMessage將準備好的消息寫入連接。",
        "uefpY5h": "撥號程序包含用於連接到WebSocket服務器的選項。",
        "P8TXR8q": "Dial通過調用帶有背景上下文的DialContext來創建新的客戶端連接。",
        "B7cmEvf": "DialContext創建一個新的客戶端連接。使用requestHeader指定源（Origin），子協議（Sec-WebSocket-Protocol）和cookie（Cookie）。使用response.Header獲取所選的子協議（Sec-WebSocket-Protocol）和cookie（Set-Cookie）。",
        "2HECSsy": "上下文將在請求和撥號器中使用。",
        "qBm2Ueg": "如果WebSocket握手失敗，則返回ErrBadHandshake以及非nil * http.Response，以便調用者可以處理重定向，身份驗證等。響應正文可能不包含整個響應，也不需要由應用程序關閉。",
        "sqSw8KU": "HandshakeError描述了來自對等方的握手錯誤。",
        "wa4jDrn": "PreparedMessage緩存消息有效負載的線表示。使用PreparedMessage有效地將消息有效負載發送到多個連接。 PreparedMessage在使用壓縮時特別有用，因為對於給定的一組壓縮選項，CPU和內存昂貴的壓縮操作可以執行一次。",
        "m9Hyk5Y": "NewPreparedMessage返回初始化的PreparedMessage。然後，您可以使用WritePreparedMessage方法將其發送到連接。對於一組當前連接選項，有效的線表示將僅延遲計算一次。",
        "jr8FrHh": "Upgrader指定用於將HTTP連接升級到WebSocket連接的參數。",
        "3wkQzn8": "升級會將HTTP服務器連接升級到WebSocket協議。",
        "gWqxm2Z": "responseHeader包含在對客戶端升級請求的響應中。使用responseHeader指定cookie（Set-Cookie）和應用程序協商的子協議（Sec-WebSocket-Protocol）。",
        "KhuHxcw": "如果升級失敗，則升級將使用HTTP錯誤響應回复客戶端。",
        "4bE3u3L": "目錄",
        "GVuX4v2": "路徑",
        "dPUcbc5": "概要",
        "V3jrrVV": "命令服務器是Autobahn WebSockets測試套件的測試服務器。"
    }
}
